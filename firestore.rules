rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------- Helpers -----------------
    function isSignedIn() { return request.auth != null; }
    function isSelf(uid) { return isSignedIn() && request.auth.uid == uid; }

    function userDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    // Returns [] if roles missing or not a list
    function rolesArray() {
      return (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
              userDoc().data.roles is list)
             ? userDoc().data.roles : [];
    }

    function isAdmin() {
      return isSignedIn() && rolesArray().hasAny(['admin']);
    }

    // ----------------- users -----------------
    match /users/{uid} {
      allow read: if isSignedIn();
      allow write: if isAdmin() || isSelf(uid);
    }

    // ----------------- events -----------------
    match /events/{eventId} {
      // Anyone signed in can read published events; admins can read all
      allow read: if isAdmin() || resource.data.status == 'published';

      // Only admins manage events
      allow create, update, delete: if isAdmin();

      // Per-event availability subcollection
      match /availability/{uid} {
        // Owner or admin can read
        allow read: if isAdmin() || isSelf(uid);

        // Admin can always write; owner can write unless the existing doc is finalized
        allow write: if isAdmin() || (isSelf(uid) && !(exists(resource) && resource.data.finalized == true));

        // Optional stricter validator (uncomment to enforce payload shape)
        // allow create, update: if (isAdmin() || isSelf(uid)) &&
        //   request.resource.data.status in ['yes','maybe','no'] &&
        //   request.resource.data.uid == uid;
      }
    }

    // ----------------- inquiries -----------------
    match /inquiries/{inquiryId} {
      // Public can create inquiries (tighten if desired)
      allow create: if
        request.resource.data.name is string && request.resource.data.name.size() > 0 && request.resource.data.name.size() <= 200 &&
        request.resource.data.email is string && request.resource.data.email.size() > 0 && request.resource.data.email.size() <= 320 &&
        (!('phone' in request.resource.data) || request.resource.data.phone is string) &&
        (!('org' in request.resource.data) || request.resource.data.org is string) &&
        (!('message' in request.resource.data) || (request.resource.data.message is string && request.resource.data.message.size() <= 5000)) &&
        (!('event' in request.resource.data) || (
          request.resource.data.event is map &&
          (!('title' in request.resource.data.event) || request.resource.data.event.title is string) &&
          (!('date' in request.resource.data.event) || request.resource.data.event.date is string) &&
          (!('start' in request.resource.data.event) || request.resource.data.event.start is string) &&
          (!('end' in request.resource.data.event) || request.resource.data.event.end is string) &&
          (!('location' in request.resource.data.event) || request.resource.data.event.location is string)
        )) &&
        (!('meta' in request.resource.data) || (
          request.resource.data.meta is map &&
          request.resource.data.meta.keys().hasOnly(['userAgent','tz']) &&
          (!('userAgent' in request.resource.data.meta) || request.resource.data.meta.userAgent is string) &&
          (!('tz' in request.resource.data.meta) || request.resource.data.meta.tz is string)
        )) &&
        (!('createdAt' in request.resource.data) || request.resource.data.createdAt is timestamp) &&
        (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp) &&
        (!('status' in request.resource.data) || request.resource.data.status in ['new','in_progress','closed']);

      // Admin-only read/update/delete of inquiries
      allow read, update, delete: if isAdmin();

      // Per-inquiry availability subcollection
      match /availability/{uid} {
        allow read: if isAdmin() || isSelf(uid);
        allow write: if isAdmin() || (isSelf(uid) && !(exists(resource) && resource.data.finalized == true));
        // allow create, update: if request.resource.data.uid == uid; // optional
      }
    }

    // ----------------- top-level mirrors -----------------
    // availability/{flatId}
    match /availability/{flatId} {
      // Admins can read; owner may read their own if you want (keep strict for reports)
      allow read: if isAdmin();
      // Admin or owner can write mirror
      allow write: if isAdmin() || (isSignedIn() && request.resource.data.uid == request.auth.uid);
    }

    // availability_responses/{flatId}
    match /availability_responses/{flatId} {
      allow read: if isAdmin() || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow list: if isAdmin();
      allow write: if isAdmin() || (isSignedIn() && request.resource.data.uid == request.auth.uid && request.resource.data.status in ['yes','maybe','no']);
    }

    // ----------------- social_polls (example app area) -----------------
    match /social_polls/halloween2025/responses/{uid} {
      allow read: if isSignedIn();
      allow write: if isSelf(uid);
    }

    match /social_polls/halloween2025/markers/{uid} {
      allow read: if isSignedIn();
      allow write: if isSelf(uid);
    }

    match /social_polls/halloween2025 {
      allow read: if isSignedIn();
      allow write: if false; // block direct edits
    }
  }
}
